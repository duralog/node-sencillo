So we have a commit

we need to wrap it

we don't want to block the main thread while we extract data from libgit2

we start off by grabbing the commit needed, for example git_commit_parent

When we get back on the main thread we pass the commit to repo, along with the original callback.

Repo examines objectstore and sees if there's an object available.

If so, call the callback with the object. done.

If not, create the Commit object, and then go to eio threadpool to load all the data into commit. Also create a mutex on the commit. In eio threadpool, populate all data then unlock the mutex.

The process that creates the mutex will also call Ref() on the new commit to ensure it doesn't get raped by V8. The process that 

If, in this time, any other requests come in for the same commit, they will go through the same process of passing commit to repo, however the repo will put them in a different eio method that will instead attempt to lock the commit mutex, 

and then unlock it immediately after. Once they go back to main thread they will return the object to callback.



Commit will have two locks, one called the "gatekeeper" which will provide critical area access to the boolean variable stating whether or not the commit is initialized or not, and also provide a lock for the other lock. the other lock is what 

threads will block on waiting for initialization to be done.





IN SUMMARY

In MAIN THREAD

Repo will check if object is created yet.  If it is, call --isInitialized();-- to make sure it's ready to send back to js. If it is, pass back. If not, call --registerInitInterest()-- to increase ref counter on the object (to prevent any inopportune GC), then spin 

up a thread to call --waitForInitialization();--, which will return once object is ready for prime-time. Once back in main thread, decrease ref count on Commit via --removeInitInterest();--.

In EIO

As soon as initialized, call --waitForInitialization()--. This will block current thread until initialized. If no thread is initializing the commit yet, then the function will return true inidicating thread should start building object data and load it up. When 

initialization is done the thread should call --initializationDone()--.







final words on synchronous



Synchronous version of this would do the following:

get commit
call --syncReturnCommit()--

syncReturnCommit will perform the same steps as the asynchronous version, this includes checking if object has been initialized yet, and then initializing it. Going through the same process of isInitialized() etc ensures we don't cause any 

memory corruption. In the worst case scenario two requesters ask for the exact same commit at the exact same time, one sync the other async. If the async was to get to the point of waitForInitialization() first it would mean the main thread 

would sit and wait for the async eio thread to build the commit data.

Oh fuck

That would cause a deadlock 'cos the main thread would spin indefinitely and the worker thread would never get to come back to the main loop to flag that the commit has been built.

Shit ok

So here's what we'll do

The async version will build the data then call initializationDone() IN THE EIO THREAD, except this method will now accept a void ptr to the data that was built. This method will of course be protected by mutex. However the data will not 

actually be loaded until the main thread does something about it. This will be via a final method call called --ensureInitDone();--, which will be tasked with checking if data package is present, if so call a virtual method (to be implemented by 

specific objects) that will consume the data and delete the pointer. This way even if the async thread got there first, and built the data, if the main thread that was blocking for the data to be built would then be allowed through and would end 

up calling ensureInitDone(); first which would of course load the data in before the async flow got back to the main thread.


WHAT ABOUT NEWLY CREATED OBJECTS?

Async:

call git_commit_create in eio

when you come back, same process:

 